// Code generated by hertz generator.

package comical_tool

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	comical_tool "github.com/kiritoxkiriko/comical-tool/biz/model/comical_tool"
	"github.com/kiritoxkiriko/comical-tool/internal/config"
	"github.com/kiritoxkiriko/comical-tool/internal/database"
	"github.com/kiritoxkiriko/comical-tool/internal/models"
	"github.com/kiritoxkiriko/comical-tool/internal/redis"
	"github.com/kiritoxkiriko/comical-tool/internal/services"
)

var (
	shortService     *services.ShortService
	analyticsService *services.AnalyticsService
	cfg              *config.Config
)

// InitServices initializes the services
func InitServices() error {
	var err error
	cfg, err = config.LoadConfig()
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	// Initialize database
	err = database.InitDatabase(cfg)
	if err != nil {
		return fmt.Errorf("failed to initialize database: %w", err)
	}

	// Initialize Redis
	err = redis.InitRedis(cfg)
	if err != nil {
		return fmt.Errorf("failed to initialize Redis: %w", err)
	}

	// Create services
	shortService = services.NewShortService(cfg)
	analyticsService = services.NewAnalyticsService()

	return nil
}

// CreateShort .
// @router /api/v1/urls [POST]
func CreateShort(ctx context.Context, c *app.RequestContext) {
	var err error
	var req comical_tool.CreateShortRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, utils.H{
			"error":   "Invalid request",
			"details": err.Error(),
		})
		return
	}

	// Convert to internal model
	var maxClicks *int
	if req.MaxClicks != nil {
		val := int(*req.MaxClicks)
		maxClicks = &val
	}

	createReq := &models.CreateShortRequest{
		OriginalURL: req.OriginalURL,
		CustomCode:  req.CustomCode,
		ExpiresAt:   parseTimePtr(req.ExpiresAt),
		MaxClicks:   maxClicks,
	}

	response, err := shortService.CreateShort(ctx, createReq)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, utils.H{
			"error":   "Failed to create short URL",
			"details": err.Error(),
		})
		return
	}

	// Convert to response model
	var responseMaxClicks *int32
	if response.MaxClicks != nil {
		val := int32(*response.MaxClicks)
		responseMaxClicks = &val
	}

	resp := &comical_tool.CreateShortResponse{
		ShortURL:    response.ShortURL,
		OriginalURL: response.OriginalURL,
		CreatedAt:   response.CreatedAt.Format(time.RFC3339),
		ExpiresAt:   formatTimePtr(response.ExpiresAt),
		MaxClicks:   responseMaxClicks,
	}

	c.JSON(consts.StatusCreated, resp)
}

// GetShort .
// @router /api/v1/urls/:code [GET]
func GetShort(ctx context.Context, c *app.RequestContext) {
	var err error
	var req string
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, utils.H{
			"error": "Code parameter is required",
		})
		return
	}

	response, err := shortService.GetShort(ctx, req)
	if err != nil {
		c.JSON(consts.StatusNotFound, utils.H{
			"error":   "Short URL not found",
			"details": err.Error(),
		})
		return
	}

	// Convert to response model
	var responseMaxClicks *int32
	if response.MaxClicks != nil {
		val := int32(*response.MaxClicks)
		responseMaxClicks = &val
	}

	resp := &comical_tool.GetShortResponse{
		ShortURL:    response.ShortURL,
		OriginalURL: response.OriginalURL,
		CreatedAt:   response.CreatedAt.Format(time.RFC3339),
		ExpiresAt:   formatTimePtr(response.ExpiresAt),
		MaxClicks:   responseMaxClicks,
		ClickCount:  int32(response.ClickCount),
	}

	c.JSON(consts.StatusOK, resp)
}

// UpdateShort .
// @router /api/v1/urls/:code [PUT]
func UpdateShort(ctx context.Context, c *app.RequestContext) {
	var err error
	var req comical_tool.UpdateShortRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, utils.H{
			"error":   "Invalid request",
			"details": err.Error(),
		})
		return
	}

	// Convert to internal model
	var maxClicks *int
	if req.MaxClicks != nil {
		val := int(*req.MaxClicks)
		maxClicks = &val
	}

	updateReq := &models.UpdateShortRequest{
		ExpiresAt: parseTimePtr(req.ExpiresAt),
		MaxClicks: maxClicks,
		IsActive:  req.IsActive,
	}

	err = shortService.UpdateShort(ctx, req.Code, updateReq)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, utils.H{
			"error":   "Failed to update short URL",
			"details": err.Error(),
		})
		return
	}

	resp := &comical_tool.UpdateShortResponse{
		Success: true,
		Message: "Short URL updated successfully",
	}

	c.JSON(consts.StatusOK, resp)
}

// DeleteShort .
// @router /api/v1/urls/:code [DELETE]
func DeleteShort(ctx context.Context, c *app.RequestContext) {
	var err error
	var req string
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, utils.H{
			"error": "Code parameter is required",
		})
		return
	}

	err = shortService.DeleteShort(ctx, req)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, utils.H{
			"error":   "Failed to delete short URL",
			"details": err.Error(),
		})
		return
	}

	resp := &comical_tool.DeleteShortResponse{
		Success: true,
		Message: "Short URL deleted successfully",
	}

	c.JSON(consts.StatusOK, resp)
}

// GetAnalytics .
// @router /api/v1/urls/:code/analytics [GET]
func GetAnalytics(ctx context.Context, c *app.RequestContext) {
	var err error
	var req comical_tool.GetAnalyticsRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, utils.H{
			"error":   "Invalid request",
			"details": err.Error(),
		})
		return
	}

	// Parse date parameters
	var startDate, endDate *time.Time
	if req.StartDate != nil {
		if parsed, err := time.Parse("2006-01-02", *req.StartDate); err == nil {
			startDate = &parsed
		}
	}
	if req.EndDate != nil {
		if parsed, err := time.Parse("2006-01-02", *req.EndDate); err == nil {
			endDate = &parsed
		}
	}

	response, err := analyticsService.GetAnalytics(ctx, req.Code, startDate, endDate)
	if err != nil {
		c.JSON(consts.StatusNotFound, utils.H{
			"error":   "Failed to get analytics",
			"details": err.Error(),
		})
		return
	}

	// Convert to response model
	resp := &comical_tool.AnalyticsResponse{
		TotalClicks: int32(response.TotalClicks),
		DailyClicks: convertDailyClicks(response.DailyClicks),
		Referrers:   convertReferrers(response.Referrers),
		Countries:   convertCountries(response.Countries),
		UserAgents:  convertUserAgents(response.UserAgents),
	}

	c.JSON(consts.StatusOK, resp)
}

// GetClickHistory .
// @router /api/v1/urls/:code/clicks [GET]
func GetClickHistory(ctx context.Context, c *app.RequestContext) {
	var err error
	var req comical_tool.GetClickHistoryRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, utils.H{
			"error":   "Invalid request",
			"details": err.Error(),
		})
		return
	}

	// Set defaults
	page := 1
	limit := 20
	if req.Page != nil {
		page = int(*req.Page)
	}
	if req.Limit != nil {
		limit = int(*req.Limit)
	}

	// Parse date parameters
	var startDate, endDate *time.Time
	if req.StartDate != nil {
		if parsed, err := time.Parse("2006-01-02", *req.StartDate); err == nil {
			startDate = &parsed
		}
	}
	if req.EndDate != nil {
		if parsed, err := time.Parse("2006-01-02", *req.EndDate); err == nil {
			endDate = &parsed
		}
	}

	response, err := analyticsService.GetClickHistory(ctx, req.Code, page, limit, startDate, endDate)
	if err != nil {
		c.JSON(consts.StatusNotFound, utils.H{
			"error":   "Failed to get click history",
			"details": err.Error(),
		})
		return
	}

	// Convert to response model
	resp := &comical_tool.ClickHistoryResponse{
		Clicks: convertClicks(response.Clicks),
		Pagination: &comical_tool.Pagination{
			Page:  int32(response.Pagination.Page),
			Limit: int32(response.Pagination.Limit),
			Total: int32(response.Pagination.Total),
			Pages: int32(response.Pagination.Pages),
		},
	}

	c.JSON(consts.StatusOK, resp)
}

// Redirect .
// @router /:code [GET]
func Redirect(ctx context.Context, c *app.RequestContext) {
	var err error
	var req string
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, utils.H{
			"error": "Code parameter is required",
		})
		return
	}

	// Get original URL
	originalURL, err := shortService.GetOriginalURL(ctx, req)
	if err != nil {
		c.JSON(consts.StatusNotFound, utils.H{
			"error":   "Short URL not found or expired",
			"details": err.Error(),
		})
		return
	}

	// Track click
	go func() {
		// Get client IP
		ipAddress := c.ClientIP()

		// Get user agent
		userAgent := string(c.Request.Header.Peek("User-Agent"))

		// Get referrer
		referrer := string(c.Request.Header.Peek("Referer"))

		// TODO: Implement geolocation service
		country := "Unknown"
		city := "Unknown"

		// Track the click
		analyticsService.TrackClick(context.Background(), req, ipAddress, userAgent, referrer, country, city)
	}()

	// Redirect to original URL
	c.Redirect(http.StatusFound, []byte(originalURL))
}

// Helper functions

// parseTimePtr parses a string pointer to time pointer
func parseTimePtr(timeStr *string) *time.Time {
	if timeStr == nil {
		return nil
	}
	if parsed, err := time.Parse(time.RFC3339, *timeStr); err == nil {
		return &parsed
	}
	return nil
}

// formatTimePtr formats a time pointer to string pointer
func formatTimePtr(t *time.Time) *string {
	if t == nil {
		return nil
	}
	formatted := t.Format(time.RFC3339)
	return &formatted
}

// convertDailyClicks converts daily clicks data
func convertDailyClicks(dailyClicks []models.DailyClickData) []*comical_tool.DailyClickData {
	result := make([]*comical_tool.DailyClickData, len(dailyClicks))
	for i, dc := range dailyClicks {
		result[i] = &comical_tool.DailyClickData{
			Date:   dc.Date,
			Clicks: int32(dc.Clicks),
		}
	}
	return result
}

// convertReferrers converts referrer data
func convertReferrers(referrers []models.ReferrerData) []*comical_tool.ReferrerData {
	result := make([]*comical_tool.ReferrerData, len(referrers))
	for i, r := range referrers {
		result[i] = &comical_tool.ReferrerData{
			Referrer: r.Referrer,
			Count:    int32(r.Count),
		}
	}
	return result
}

// convertCountries converts country data
func convertCountries(countries []models.CountryData) []*comical_tool.CountryData {
	result := make([]*comical_tool.CountryData, len(countries))
	for i, c := range countries {
		result[i] = &comical_tool.CountryData{
			Country: c.Country,
			Count:   int32(c.Count),
		}
	}
	return result
}

// convertUserAgents converts user agent data
func convertUserAgents(userAgents []models.UserAgentData) []*comical_tool.UserAgentData {
	result := make([]*comical_tool.UserAgentData, len(userAgents))
	for i, ua := range userAgents {
		result[i] = &comical_tool.UserAgentData{
			UserAgent: ua.UserAgent,
			Count:     int32(ua.Count),
		}
	}
	return result
}

// convertClicks converts click data
func convertClicks(clicks []models.ClickData) []*comical_tool.ClickData {
	result := make([]*comical_tool.ClickData, len(clicks))
	for i, c := range clicks {
		result[i] = &comical_tool.ClickData{
			IPAddress: c.IPAddress,
			UserAgent: c.UserAgent,
			Referrer:  c.Referrer,
			Country:   c.Country,
			City:      c.City,
			ClickedAt: c.ClickedAt.Format(time.RFC3339),
		}
	}
	return result
}
